
# What is Supply Chain Security?

In modern software development, you rarely write 100% of your own code. Instead, you assemble products using a vast ecosystem of third-party libraries, build tools, container images, and CI/CD pipelines.
**Supply Chain Security** is the practice of ensuring that every component, process, and actor involved in the creation and delivery of your software is verified, untampered, and trustworthy.

## What is the Software Supply Chain?

A software supply chain consists of all the steps and components involved in creating, building, and deploying software in the [Software Development Life Cycle](https://en.wikipedia.org/wiki/Systems_development_life_cycle). 
It includes the tools, processes, and people responsible for transforming source code into a deployable application.

The software supply chain for a typical project could involve for example (not exhaustive):

- A developer writing source code
- Version control systems (Git, SVN, etc.)
- Third-party software libraries
- Build tools (Maven, make, etc.)
- CI/CD software (Jenkins, GitHub Actions, etc.)
- Deployment system packaging the executable into a Docker image
- Container registry storing the Docker image for deployment
- Production environment running the Docker image
- Package management software and ecosystems (npm, pip, etc.)
- ...

Every one of these components has to be secured. A single vulnerability can put the entire software supply chain at risk.

## The Threat Landscape

Understanding the potential threats to the software supply chain is crucial for ensuring its security.
By mapping the software supply chain, we can pinpoint vulnerabilities throughout the development lifecycle. These risks are categorized into four strategic domains: Source, Build, Dependency, and Deployment/Runtime threats.

![Software Supply Chain Threat Model](/threat-landscape.png)

### 1. Source Threats
These risks target the earliest stage of development—the code itself and the systems that manage it. Attackers aim to compromise source code repositories to inject malicious code or steal intellectual property before the build process even begins.

#### Examples of Source Threats

  * **Unauthorized Code Changes:** An attacker gains access to a developer's account or maintainer rights for a public repository and silently commits a backdoor into the codebase.
  * **Repo Configuration Weaknesses:** A public GitHub repository is accidentally configured to allow anyone to push code, or branch protection rules are bypassed.
  * **Insufficient Code Review:** Malicious or vulnerable code is merged into the main branch because peer review processes were skipped or automated scanners were ignored.

![XZ_utils_logo_contributed_by_Jia_Tan](/XZ_logo_contributed_by_Jia_Tan.png)
<a href="https://commons.wikimedia.org/wiki/File:XZ_logo_contributed_by_Jia_Tan.png">Jia Tan</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>, via Wikimedia Commons

**Real-World Example: [The 2024 XZ Utils Backdoor](https://en.wikipedia.org/wiki/XZ_Utils_backdoor)**
In this sophisticated social engineering attack, a malicious actor known as "Jia Tan" spent years building trust to gain maintainer rights over **XZ Utils**, a widely used compression library. Once in control, they injected a backdoor designed to allow unauthorized **remote code execution** on Linux servers.

**Impact:** The attack was discovered by chance just weeks before it would have merged into stable Linux distributions. While this miracle discovery prevented the infection of **hundreds of millions of servers** globally, the compromised versions (5.6.0 and 5.6.1) still reached users of rolling-release distributions like Fedora Rawhide, Kali Linux, and openSUSE Tumbleweed.



---

### 2. Build Threats
Build threats focus on the "factory" where code is turned into executable software. If the build environment or the process is compromised, the resulting artifact will be malicious, even if the original source code was clean.

#### Examples of Build Threats

  * **Compromised Build Server:** An attacker infects the CI/CD pipeline (e.g., Jenkins or GitHub Actions), causing it to inject malware during the compilation process.
  * **Environmental Drift:** The build environment uses outdated or unpatched tools that have known vulnerabilities, which attackers exploit to alter the build output.
  * **Artifact Tampering:** A legitimate binary is replaced with a malicious version immediately after the build is completed but before it is signed or stored.

**Real-World Example: [SolarWinds Incident (2020)](https://en.wikipedia.org/wiki/2020_United_States_federal_government_data_breach#Methodology)**
This incident illustrates a critical failure in build security. Attackers compromised the **build environment and continuous integration server**, allowing them to modify and infect software updates for the **Orion** network monitoring tool.

**Impact:** The fallout was severe, reaching over a dozen U.S. government departments—including the **military, executive branch, and intelligence services**—who unknowingly installed the compromised updates.

---

### 3. Dependency Threats
Modern software relies heavily on third-party libraries and open-source packages. Dependency threats exploit this trust by introducing vulnerabilities through the external components your software consumes.

#### Examples of Dependency Threats

  * **Typosquatting:** An attacker publishes a malicious package with a name very similar to a popular library (e.g., `react-dom` vs. `reac-dom`), hoping developers install the wrong one by mistake.
  * **Dependency Confusion:** An attacker uploads a malicious package to a public registry with the same name as an internal, private package, tricking the build system into pulling the public (malicious) version.
  * **Vulnerable Transitive Dependencies:** A library you use depends on *another* library that has a critical vulnerability (like Log4j), compromising your application indirectly.

**Real-World Example: [Log4Shell (2021)](https://en.wikipedia.org/wiki/Log4Shell)**
The **Log4Shell** vulnerability in the ubiquitous Java logging library **Log4j** demonstrates the massive reach of dependency threats. A critical flaw in how the library processed log messages allowed attackers to execute arbitrary code remotely (RCE) simply by sending a specific text string to a vulnerable server.

**Impact:** Because Log4j was embedded as a dependency in **millions of applications**—from iCloud and Steam to enterprise software—the vulnerability left a vast portion of the internet exposed. It forced organizations globally to pause development and scramble to patch deep chains of transitive dependencies.


---

### 4. Deployment and Runtime Threats
These threats occur after the software has been built and is running in its destination environment. Attackers target the deployment infrastructure or the application while it is active to manipulate its behavior or steal data.

#### Examples of Deployment Threats

  * **Insecure Infrastructure-as-Code (IaC):** Deployment scripts (e.g., Terraform or Kubernetes manifests) are misconfigured, leaving cloud buckets or API endpoints exposed to the public.
  * **Runtime Injection:** An application running in production is exploited via a vulnerability (like SQL Injection or Remote Code Execution) to execute malicious commands.
  * **Unverified Artifact Deployment:** The production environment accepts and runs a container image that hasn't been signed or verified, allowing an attacker to deploy a rogue version of the application.

**Real-World Example: [The Equifax Data Breach (2017)](https://en.wikipedia.org/wiki/2017_Equifax_data_breach)**
While often cited as a failure to patch, this incident fundamentally illustrates a **Runtime Injection** attack via a supply chain dependency. Equifax was running a version of the **Apache Struts** framework with a known flaw (CVE-2017-5638) in how it parsed HTTP headers.

Attackers exploited this by sending web requests with malicious commands injected into the `Content-Type` header. The running application parsed the header and immediately executed the code within it, allowing attackers to bypass authentication entirely.

**Impact:** The breach resulted in the theft of **147.9 million American consumer records**. It also exposed data for 15.2 million UK citizens and compromised approximately 10–11 million drivers' licenses, highlighting how a single runtime vulnerability can lead to catastrophic data loss.


---

## Why Traditional Security is Insufficient

Traditional security often focuses on the **final product** (e.g., scanning a finished Docker image for CVEs). However, this is a reactive approach that has several blind spots:

1.  **The Metadata Gap**: A scan tells you what vulnerabilities are inside *now*, but it doesn't tell you *how* the image was made. If the image was built on an unauthenticated laptop instead of a secured CI runner, the scan might pass, but the provenance is untrusted.
2.  **Point-in-Time Limitations**: Vulnerabilities are discovered daily. An artifact that was "clean" at 9:00 AM might be "critical" at 2:00 PM.
3.  **Process Blindness**: Traditional scanners cannot detect if an attacker injected a backdoor into the binary that doesn't match a known CVE signature. Only **Supply Chain Verification** (comparing source to build output) can mitigate this.

---

## The Building Blocks of Trust in DevGuard

DevGuard uses a **"Verify, then Trust"** model. This relies on three conceptual pillars that are explored in depth throughout this chapter:

### Transparency via SBOMs
A **Software Bill of Materials (SBOM)** is the ingredient list of your software. Without a comprehensive SBOM, you cannot defend against what you don't know you have. DevGuard uses SBOMs to map your "attack surface" across the entire organization.
* *Detailed in: [SBOM Standards](./compliance/sbom-standards.mdx)*

### Evidence via Attestations
Attestations are digital statements about a software artifact or process. Think of them as "notarized" documents. For example, a build platform might attest: *"I built Artifact X from Source Y using Build Script Z."* DevGuard stores and evaluates these to ensure no steps were skipped.
* *Detailed in: [Attestations](./supply-chain-security/attestations.mdx)*

### Proof of Process via In-toto
While an SBOM tells you *what* is inside, the **In-toto framework** tells you *how* it got there. It defines a layout of expected steps and verifies that the people or machines performing those steps are authorized via cryptographic keys.
* *Detailed in: [In-toto Framework](./supply-chain-security/in-toto-framework.mdx)*

---

## Strategic Implementation: Shift Left and Guard Right

Supply chain security is often associated with "shifting left" (testing earlier). DevGuard expands this by also "guarding right."

### The "Shift Left" (Prevention)
We provide developers with immediate feedback. By integrating with the developer's IDE or the first pull request scan, DevGuard identifies malicious dependencies before they are ever merged into the main branch. This prevents the "poisoning" of the source.

### The "Guard Right" (Enforcement)
Even if a developer bypasses a local check, the CI/CD pipeline and the final production deployment are gated by **Attestation Policies**. If an artifact arrives at the production environment without a valid signature from the build runner or a passing security scan attestation, DevGuard can trigger an alert or block the deployment.



---

## Conclusion

Supply Chain Security is no longer optional in an era of automated, multi-layered software delivery. It requires moving beyond simple vulnerability scanning and into the realm of **provenance and integrity**. By understanding the flow of code from source to production, and by demanding cryptographic proof of every transformation, organizations can significantly reduce the risk of sophisticated supply chain attacks.

In the following sections, we will explore the specific frameworks DevGuard uses to implement these concepts, including In-toto, SLSA, and the relationship between Attestations and VEX.

---

## References

* [OWASP Software Supply Chain Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Software_Supply_Chain_Security_Cheat_Sheet.html)
* [SLSA Threats Overview (v1.0)](https://slsa.dev/spec/v1.0/threats-overview)
* [CNCF Software Supply Chain Best Practices Whitepaper](https://github.com/cncf/tag-security/blob/main/supply-chain-security/supply-chain-security-paper/v1/software-supply-chain-security-paper-v1.md)

---