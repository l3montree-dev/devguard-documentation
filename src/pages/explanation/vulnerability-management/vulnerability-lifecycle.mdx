import Image from 'next/image';
import { Callout } from 'nextra/components';

# Vulnerability States

Effective vulnerability management requires clear communication about how security findings affect your applications. Vulnerability states provide a standardized framework for classifying and communicating the relationship between identified vulnerabilities and your specific systemsâ€”answering the fundamental question: *Does this vulnerability actually impact our application?*

When vulnerability scanners identify thousands of potential security issues across your dependencies, not all findings represent real risk. A vulnerability in a library doesn't necessarily mean your application is exploitable. Understanding and properly assigning vulnerability states transforms raw scan data into actionable intelligence, enabling teams to focus remediation efforts where they matter most.

<Callout type="info" emoji="â„¹ï¸">
  Vulnerability states are based on the VEX (Vulnerability Exploitability eXchange) standard, which provides a common language for sharing exploitability assessments. This standardization enables consistent communication about security posture both within your organization and with customers or downstream consumers of your software.
</Callout>

## The Four Vulnerability States

The VEX standard defines four distinct states that describe the relationship between a vulnerability and a product[^1]. Each state represents a different level of concern and requires different actions from security and development teams.

### Affected

The **Affected** state indicates that a vulnerability impacts your application and requires remediation. This is the default state for newly discovered vulnerabilitiesâ€”when a security scanner identifies a CVE in your dependencies, it initially assumes your application is affected until proven otherwise.

**What it means**: The vulnerable code exists in your application, is reachable through your code paths, and could potentially be exploited if an attacker can trigger the vulnerable functionality.

**Required action**: Remediation is necessary. This typically involves updating to a patched version of the dependency, applying workarounds, or implementing mitigating controls until a fix is available.

**Example**: Your web application uses an HTTP parsing library with a known remote code execution vulnerability. Your API endpoints directly process user input through this parser, making the vulnerability exploitable. This finding should remain in the Affected state until you upgrade to a patched version.

### Fixed

The **Fixed** state indicates that a vulnerability has been successfully remediated in your application. This state represents completed workâ€”the vulnerability existed and affected your system, but corrective action has eliminated the risk.

**What it means**: You've deployed a fix that removes the vulnerability from your production environment. This might be an updated dependency version, a code change that eliminates the vulnerable functionality, or implementation of effective compensating controls.

**Required action**: No immediate action needed, but maintain the fix through ongoing deployment and configuration management.

**Example**: After identifying the HTTP parser vulnerability mentioned above, your team upgraded to version 2.1.5 which patches the security flaw. Once deployed to production, the vulnerability transitions to Fixed state. DevGuard continues tracking this finding to ensure the fix remains in place across all deployments.

<Callout type="info" emoji="âœ…">
  DevGuard automatically detects when vulnerabilities are fixed by monitoring your dependency versions. When you update a vulnerable dependency to a patched version, DevGuard transitions the finding to Fixed state and can automatically close associated issue tracker tickets if synchronization is enabled.
</Callout>

### Not Affected

The **Not Affected** state indicates that while a vulnerability exists in your dependencies, it does not impact your application's security posture. This is one of the most valuable states in vulnerability managementâ€”it allows you to document why certain findings don't require remediation, preventing wasted effort and alert fatigue.

**What it means**: Through analysis, you've determined that your application cannot be exploited through this vulnerability. The vulnerable code may be present in your dependencies, but it's not used in a way that creates actual risk.

**Required action**: Document the justification for this assessment. Proper documentation is criticalâ€”it explains your reasoning to auditors, security reviewers, and future team members who may question why a "High severity" finding remains unpatched.

**Example**: Your application includes a web framework that contains a vulnerability in its WebSocket handling code. However, your application only uses the framework's HTTP routing capabilities and never enables WebSocket functionality. After analysis, you classify this as Not Affected with the justification "vulnerable code not in execute path."

We'll explore the specific justification categories in detail in the next section.

### Under Investigation

The **Under Investigation** state indicates that your team is actively analyzing whether a vulnerability affects your application. This is a transitional stateâ€”every finding in this state should eventually move to Affected, Not Affected, or Fixed after completing the assessment.

**What it means**: You've identified the vulnerability but haven't yet determined its impact on your specific deployment. Your team needs time to analyze code paths, review configurations, or perform testing to understand exploitability.

**Required action**: Complete the impact assessment as quickly as feasible. Prioritize investigations based on the vulnerability's technical severity and exploit probabilityâ€”high-risk findings should be investigated immediately.

**Example**: A new critical vulnerability is disclosed in a logging library used throughout your application. Your security team needs to analyze which logging statements include user-controlled input and whether the vulnerable code paths are reachable. During this assessment period, the finding remains Under Investigation.

<Callout type="warning" emoji="â±ï¸">
  Avoid leaving vulnerabilities in Under Investigation state indefinitely. Establish clear SLAs for completing assessments based on vulnerability severityâ€”for example, critical findings should be assessed within 24 hours, high within 72 hours. DevGuard can help track assessment timelines through issue tracker integration and notifications.
</Callout>

## Not Affected Justifications

When classifying a vulnerability as Not Affected, the VEX standard requires providing a justification that explains *why* the vulnerability doesn't impact your application[^1]. These standardized justification categories help ensure assessments are thorough and defensible.

### Vulnerable Code Not Present

The vulnerable code was removed from your version of the component, or the vulnerable code never existed in the versions you're using. This justification applies when your dependency doesn't actually contain the security flaw.

**When to use**: Your dependency version predates the introduction of the vulnerable code, or you're using a variant/fork where the vulnerable functionality was removed.

**Example**: A vulnerability is disclosed in version 3.2.0 of a library, but your application uses version 2.8.1 which doesn't contain the affected code. The vulnerable functionality was introduced after your version.

### Vulnerable Code Not in Execute Path

The vulnerable code exists in your dependencies but cannot be reached through any execution path in your application. Your code never calls the vulnerable functions, directly or indirectly.

**When to use**: After code analysis, you've confirmed that the vulnerable functionality is never invoked by your application's code paths.

**Example**: A security library you depend on has a vulnerability in its LDAP authentication module. Your application uses the library exclusively for JWT token validation and never calls any LDAP-related functions. The vulnerable code is present but unreachable.

<Callout type="info" emoji="ðŸ”">
  DevGuard's dependency tree analysis helps identify which code paths in your application actually reach vulnerable functions. This reachability analysis provides evidence for justifications based on code execution paths.
</Callout>

### Inline Mitigations Already Exist

You've implemented compensating controls that prevent exploitation of the vulnerability without patching the vulnerable component. These mitigations must actually prevent exploitationâ€”wishful thinking doesn't count.

**When to use**: You've deployed technical controls (input validation, WAF rules, network segmentation, etc.) that reliably prevent the vulnerability from being exploited in your environment.

**Example**: A SQL injection vulnerability exists in an admin panel component. You've implemented authentication requiring hardware tokens, network restrictions limiting access to a specific IP range, and comprehensive input validation that blocks SQL injection payloads. These layered controls prevent exploitation even though the vulnerable code remains.

**Important**: This justification requires careful consideration. Mitigations must be comprehensive, properly implemented, and maintained over time. Document the specific controls in detail.

### Component Not Affected

The vulnerability is specific to certain configurations, platforms, or use cases that don't apply to how you deploy the component.

**When to use**: The vulnerability only affects specific operating systems, runtime configurations, or deployment patterns that differ from your environment.

**Example**: A vulnerability in a Node.js library only affects Windows systems due to path handling differences. Your application runs exclusively on Linux containers, making the vulnerability inapplicable to your deployment.

## DevGuard's State Management

DevGuard implements vulnerability state tracking throughout its platform, integrating states into risk assessment, reporting, and workflow automation.

### Automated State Detection

DevGuard automatically manages certain state transitions based on observable changes in your environment:

**Affected â†’ Fixed**: When you update a vulnerable dependency to a patched version, DevGuard detects this during the next scan and automatically transitions the vulnerability to Fixed state. This eliminates manual tracking overhead for routine patches.

**Fixed â†’ Affected**: If you inadvertently roll back to a vulnerable version (for example, due to dependency conflicts during an update), DevGuard detects the regression and reopens the finding as Affected.

### Manual State Assignment

For Not Affected and Under Investigation states, DevGuard provides interfaces for security and development teams to manually assign states with justifications:

- **Web UI**: Review findings and assign states with detailed justifications through DevGuard's vulnerability management interface
- **Issue Tracker Integration**: Update vulnerability states directly in your existing workflow tools (GitHub Issues, GitLab Issues, Jira)
- **VEX Documents**: Import state assessments from VEX files provided by your suppliers or security team

<Callout type="info" emoji="ðŸ”„">
  When you mark a vulnerability as Not Affected in DevGuard, you can document your justification using the standardized VEX categories. This documentation is included in generated VEX reports and SBOM exports, enabling you to communicate your security assessment to customers and auditors.
</Callout>

### Risk Score Adjustment

Vulnerability states directly influence DevGuard's risk calculations. Findings marked as Not Affected or Fixed receive reduced risk scores, ensuring they don't interfere with prioritization of genuine threats:

- **Not Affected**: Risk score approaches zero, as the vulnerability doesn't represent actual risk to your deployment
- **Fixed**: Risk score is eliminated for that specific finding
- **Under Investigation**: Maintains full risk score until assessment is complete
- **Affected**: Full risk score based on CVSS, EPSS, and contextual factors

This state-aware risk scoring ensures your vulnerability dashboards and reports focus attention on actual risks rather than theoretical findings.

### VEX Exchange

DevGuard supports importing and exporting VEX documents, enabling standardized communication about vulnerability states:

**Importing VEX**: When your software suppliers provide VEX documents describing which vulnerabilities affect their components, DevGuard can import these assessments to reduce false positives in your scans.

**Exporting VEX**: DevGuard generates VEX documents describing the vulnerability state of your applications, allowing you to communicate your security posture to downstream consumers, customers, or compliance auditors.

## Best Practices for State Management

1. **Document All Assessments**: Every Not Affected classification should include a clear, detailed justification. Future team members, auditors, and security reviewers will need to understand your reasoning.

2. **Regular Reassessment**: Periodically review Not Affected findings, especially after major code changes. What was once unreachable code might become active after refactoring or feature additions.

3. **Prioritize Investigation by Risk**: Use vulnerability risk scores to prioritize which findings to investigate first. Critical vulnerabilities with high EPSS scores demand immediate assessment, while low-risk findings can be evaluated during routine reviews.

4. **Establish Clear SLAs**: Define time limits for completing vulnerability investigations based on severity levels. Track these SLAs through issue tracker integration.

5. **Leverage Automation**: Allow DevGuard to automatically handle state transitions for patched vulnerabilities. Focus your team's effort on the analysis that requires human judgmentâ€”determining which findings are genuinely Not Affected.

6. **Communicate States Externally**: When customers or partners ask about vulnerabilities in your software, provide VEX documents that clearly communicate your assessment. This reduces duplicate effort and builds trust.

7. **Review Mitigations Regularly**: If you've classified vulnerabilities as Not Affected based on inline mitigations, periodically verify those mitigations remain in place and effective. Configuration drift can invalidate previous assessments.

8. **Balance Perfectionism with Pragmatism**: Not every vulnerability requires deep analysis. For low-severity findings in deep transitive dependencies, reasonable assessments based on available information are acceptable. Focus detailed investigation on high-risk findings.

## Conclusion

Vulnerability states provide essential structure for managing security findings at scale. By clearly communicating whether vulnerabilities affect your applications, states enable teams to focus remediation efforts on genuine risks while documenting why certain findings don't require action.

DevGuard's implementation of VEX-based state management automates routine transitions, integrates with existing workflows, and provides the documentation needed for compliance and customer communication. This transforms vulnerability management from an overwhelming flood of findings into a systematic, defensible process.

Properly managed vulnerability states reduce alert fatigue, improve remediation prioritization, and build trust with security auditors and customersâ€”turning vulnerability management into a competitive advantage rather than a compliance burden.

---
## Related Documentation

- [Vulnerability Risk Assessment Methodology](risk-assessment-methodology) - Understanding how vulnerability risk is calculated
{/* - [Software Composition Analysis](devsecops/software-composition-analysis) - How DevGuard identifies vulnerabilities in dependencies */}
{/* - [Ingesting Upstream Information](feature-guides/ingesting-upstream-information) - Importing VEX documents from suppliers */}

## References

[^1]: CISA, *Vulnerability Exploitability eXchange (VEX) - Use Cases*, Cybersecurity and Infrastructure Security Agency, 2023


