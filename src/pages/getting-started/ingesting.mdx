# Deleting Branches and Tags

- it is possible now to delete Branches and tags from the devguard ui
   - Navigate to an url like http://localhost:3000/org1/projects/group1/assets/abnahme/refs or use the "Refs"-Selector and press on the "View all branches and tags" button


# Ingesting upstream information with DevGuard

You can upload a VeX-Document or an SBOM using the DevGuard UI and CLI.

- In the UI you can find this in the identify risk dialog (dependency risk identification and onboarding flow)
    - If you have a vex file or sbom file already, do "Use your own scanner" -> "Upload manually" -> "VEX" | "SBOM" Tab
        - After uploading the file, DevGuard will navigate you to the overview page
        - The VeX and SBOM information are ingested and risk are identified
        - You can change the origin (think of this as information source, e.g. different scan-tools or different suppliers) while uploading.
            - In onboarding pressing More-Options beneath the dropzone, in the regular risk identification dialog just beneath the dropzone
    - If your supplier provides a public url to a cyclonedx vex or sbom file, you can use the "Setup by external information source option"
      - Provide a public URL to a cyclonedx vex or sbom file
      - DevGuard will fetch the file from the URL and ingest the information

- Upload using the cli
    ```sh
    devguard-scanner vex  --token XYZ --apiUrl "http://localhost:8080" --assetName org/group1/abnahme ../example-project/vex-false-positive.json
    devguard-scanner sbom  --token XYZ --apiUrl "http://localhost:8080" --assetName org/group1/abnahme ../example-project/sbom.json
    ```


How it works:

- VeX takes precedence over SBOM information: VeX says you have vulnerability X for component Y, even if the SBOM does not list vulnerability X for component Y, DevGuard will consider vulnerability X as valid for component Y.
- Deleting the information which point to a vulnerability will fix the vulnerability for the component.
    - E.g. if you have a VeX document which says component Y has vulnerability X, deleting the VeX document will remove vulnerability X from component Y (if no other information source says that component Y has vulnerability X)
- **DevGuard will respect externalReference statements in the VeX or sbom document of type "exploitability-statement" and "bom"** (see files/vex-with-external-reference)
    - DevGuard will ingest informations from those references as well (doesnt work recursively, only one level of externalReference is supported)

- Conflict resolution:
    - If multiple VeX or SBOM documents provide conflicting information (e.g., one document states that a vulnerability is applicable to a component, while another states it is not), DevGuard will prioritize VeX documents over SBOM documents.
    - If two vex documents conflict, the behavior is non-deterministic (last one wins - but order is not defined and we are rescanning in the background)
- VeX-Events are the same, if they have the same state AND the same justification (if provided)

## Paranoid Mode
- You can enable Paranoid Mode in the Asset Settings. After that you need to explicitly allow any false-positive marking via vex documents.
- Accepted Events in the upstream document will result in -> Wont fix but still open vulnerabilities
- You can only accept an event if no state changing event (e.g. you marked it as accepted) happened AFTERWARDS.


## Public VEX and SBOM URL with externalReferences

- In the settings of an asset you can Enable public access to vulnerability data.
- Two new endpoints will be available:
    - /api/v1/public/{assetId}/vex.json
    - /api/v1/public/{assetId}/sbom.json
- These endpoints will provide the VeX and SBOM information including all externalReferences of type "exploitability-statement" and "bom" linking to themselves.
- Even the old urls will now provide the externalReference information IF the asset has public access enabled.

## Discover base image attestations

```sh
go run cmd/devguard-scanner/main.go discover-baseimage-attestations Dockerfile
```

Try with this Dockerfile!
```Dockerfile
# Copyright (C) 2024 Tim Bastin, l3montree GmbH
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

FROM golang:1.25.2-trixie@sha256:b08c20ae3aa771d333b1e2ad77986b42b1ded17362bbfdd452977bfc2b107295 AS golang-builder
ARG GITHUB_REF_NAME

WORKDIR /go/src/app
COPY . .

RUN go mod download
ENV FLAGS="ldflags='-X main.release=devguard@${GITHUB_REF_NAME}'"
RUN CGO_ENABLED=0 make devguard
RUN CGO_ENABLED=0 make devguard-cli

# --- Setting the last base image here to an image which provides attestations ;)
FROM ghcr.io/l3montree-dev/devguard:main-bd6dbc88-1762074014

USER 53111

WORKDIR /app

COPY --chown=53111:53111 config/rbac_model.conf /app/config/rbac_model.conf
COPY --chown=53111:53111 --from=golang-builder /go/src/app/devguard /usr/local/bin/devguard
COPY --chown=53111:53111 --from=golang-builder /go/src/app/devguard-cli /usr/local/bin/devguard-cli
COPY --chown=53111:53111 intoto-public-key.pem /app/intoto-public-key.pem
COPY --chown=53111:53111 cosign.pub /app/cosign.pub

CMD ["devguard"]
```

Will save base image attestations found in the Dockerfile to the local file system. File name is derived from the predicate type
