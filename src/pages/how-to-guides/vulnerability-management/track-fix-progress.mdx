---
title: Track Fix Progress
description: Monitor the remediation journey of vulnerabilities from discovery to resolution using DevGuard's tracking capabilities.
---

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Callout } from 'nextra/components';

# Track Fix Progress

Monitor and manage the remediation progress of vulnerabilities throughout their lifecycle. DevGuard provides multiple ways to track how vulnerabilities move from **open** to **fixed** status, with full audit trails and evidence documentation.

## Prerequisites

Before tracking vulnerability fix progress, ensure you have:

- **Assets created and scanned**: At least one asset with vulnerability scans completed
- **Vulnerabilities detected**: Open vulnerabilities identified through SAST, SCA, IaC, or container scanning
- **Basic understanding of vulnerability states**: Familiarity with the five vulnerability states (open, fixed, accepted, false positive, marked for transfer)
- **Access to Risk Management**: Permission to view and manage vulnerabilities in your project

## Understanding Vulnerability States

Vulnerabilities follow a lifecycle with five possible states:

| State | Meaning | Trigger |
|-------|---------|---------|
| **Open** | Newly detected vulnerability requiring action | Initial scan detection |
| **Fixed** | Vulnerability resolved through remediation | Next scan detection or manual state change |
| **Accepted** | Deliberate decision to acknowledge risk without fixing | Manual risk acceptance |
| **False Positive** | Incorrectly detected vulnerability | Manual dismissal |
| **Marked for Transfer** | Vulnerability transferred to upstream maintainer | Upstream supplier responsibility |

## How Vulnerabilities Move to Fixed

DevGuard tracks fix progress through two primary mechanisms:

### 1. Automatic Detection on Next Scan

When you remediate a vulnerability (by updating dependencies, patching code, etc.) and run a new scan:

1. **Scan identifies the fix**: The vulnerability is no longer detected in your codebase
2. **Status updates automatically**: DevGuard marks it as **Fixed** in the current asset version
3. **Event recorded**: A "Fixed" event is added to the vulnerability's history with scan timestamp

This is the most reliable way to confirm fixes, as it's backed by actual scan evidence.

### 2. Manual Status Change

You can manually change a vulnerability's status for cases where automatic detection isn't possible:

1. Navigate to the vulnerability detail page
2. Click the **Change Status** or state badge
3. Select **Mark as Fixed**
4. Provide a justification explaining the fix (manual or mechanical)
5. Save the change

Manual state changes are useful for:
- **Hotfixes not yet in production**: You've fixed the code but haven't deployed
- **Dependency updates in progress**: You've updated to a patched version pending deployment
- **Mitigations applied**: You've implemented compensating controls

## Tracking Mitigation Progress

DevGuard uses a **Mitigation** model to track remediation efforts with the following key attributes:

### Mitigation Types

Choose the appropriate mitigation type for your response:

| Type | Use Case | Progress Tracking |
|------|----------|-------------------|
| **Fix** | Update dependency, patch code, or upgrade component | Requires verification via next scan (MitigationPending flag) |
| **Accept** | Acknowledge risk and accept the vulnerability | Immediate state change with justification |
| **Avoid** | Implement compensating controls to mitigate exposure | No code change required |
| **Transfer** | Pass responsibility to upstream maintainer | Tracked for upstream SCA integration |

### Verification Status

When creating a **Fix** type mitigation:

- **MitigationPending**: Initially `true` - awaiting verification through next scan
- **After next scan**: Automatically set to `false` when the fix is confirmed
- **Timeout handling**: You can manually verify if automatic detection isn't working

## Viewing the Fix Timeline

Each vulnerability maintains a complete **event history** showing all state transitions:

### Accessing the Timeline

<Tabs>
<TabsList>
<TabsTrigger>Dependency Risks</TabsTrigger>
<TabsTrigger>Code Risks</TabsTrigger>
</TabsList>

<TabsContent value="Dependency Risks">
1. Navigate to **Assets** → Select your asset
2. Go to **Dependency Risks** tab
3. Click on any vulnerability to view detail page
4. Scroll to **Timeline** or **History** section
</TabsContent>

<TabsContent value="Code Risks">
1. Navigate to **Assets** → Select your asset
2. Go to **Code Risks** tab
3. Click on any vulnerability to view detail page
4. Scroll to **Timeline** or **History** section
</TabsContent>

</Tabs>

### Timeline Information

The timeline displays for each state change:

- **Event Type**: Fixed, Accepted, False Positive, Reopened, Comment, or Marked for Transfer
- **Timestamp**: When the state change occurred (or scan was performed)
- **User**: Who made the change (for manual state changes)
- **Justification**: Manual explanation of the decision
- **Evidence**: Mechanical justifications (e.g., VEX statements, component removal)

## Justifying Fix Progress

When updating vulnerability status, provide justifications to document your decision:

### Manual Justification

Free-form text explanation of how you addressed the vulnerability:

```
"Updated log4j from 2.14.1 to 2.17.0 which contains the fix for CVE-2021-44228. 
Verified with security team on 2024-01-15."
```

### Mechanical Justification (VEX-based)

Select from predefined justification types for automated tracking:

| Mechanical Type | Applies When |
|---|---|
| **component_not_present** | You've removed the vulnerable component entirely |
| **vulnerable_code_not_present** | The component is present but vulnerable code paths aren't used |
| **vulnerable_code_not_in_execute_path** | Vulnerable code exists but is unreachable in your application flow |
| **vulnerable_code_cannot_be_controlled_by_adversary** | Vulnerability exists but cannot be exploited in your context |
| **inline_mitigations_already_exist** | Compensating controls prevent exploitation |

Mechanical justifications integrate with VEX (Vulnerability Exploitability eXchange) statements from upstream suppliers.

## Practical Examples

### Example 1: Dependency Update

Tracking a successful dependency upgrade:

1. **Initial State**: Vulnerable version of `log4j 2.14.1` detected (CVE-2021-44228)
2. **Action Taken**: Update to `log4j 2.17.0` (fixed version)
3. **Trigger Scan**: Run SCA scan on updated dependencies
4. **Automatic Update**: 
   - Vulnerability automatically marked as **Fixed**
   - Event created: "Fixed (2024-01-15)" with scan evidence
   - Risk score recalculated (vulnerability no longer contributes)

### Example 2: Code Patch with Manual Verification

Handling a code security issue where automated detection isn't perfect:

1. **Initial State**: SAST detected SQL injection in authentication handler
2. **Action Taken**: Developer patches the vulnerable code path
3. **Manual Verification**: Since pattern matching might not detect all variations:
   - Navigate to vulnerability detail
   - Change state to **Fixed**
   - Add justification: "Parameterized all SQL queries in auth.go using prepared statements. Code reviewed on PR #456."
   - Select mechanical justification: "vulnerable_code_not_in_execute_path"
4. **Timeline**: Event recorded with manual justification as backup evidence

### Example 3: Risk Acceptance

Documenting deliberate acceptance of a vulnerability:

1. **Initial State**: Medium-risk IaC misconfiguration detected in staging environment
2. **Risk Assessment**: Determined not exploitable in current infrastructure architecture
3. **Decision**: Accept risk rather than immediately remediate
4. **Create Acceptance**:
   - Change state to **Accepted**
   - Add justification: "Security team reviewed: staging environment has no internet exposure. Scheduled for remediation in next hardening sprint (Q2)."
   - Set due date if planning future fix
5. **Timeline**: Event shows accepted state with rationale, indicating intentional decision

## Tracking Cross-Project Fix Progress

### Overall Risk Metrics

Monitor fix progress across your project:

1. **Dashboard Overview**: View total vulnerabilities by state
   - Current open vulnerabilities
   - Fixed this month/quarter
   - Accepted or transferred items

2. **Trend Tracking**: Historical data shows:
   - Days to fix by severity level
   - Fix rate over time
   - Trend of vulnerability introduction vs. resolution

### Asset-Level Progress

For individual assets:

1. Navigate to asset detail page
2. View **Risk Distribution** by state
3. Check **Average Fixing Time** for historical context
4. Monitor **Recent Changes** timeline

## Integration with Issue Tracking

Connect vulnerability fixes to your workflow:

### Ticket Linking

When fixing vulnerabilities, link to external issue trackers:

- **GitHub Issues**: Automatically create or link PRs with `github:org/repo#123`
- **GitLab Issues**: Track with `gitlab:group/project#456`
- **Jira**: Link to ticket `PROJ-789`

DevGuard displays ticket links on vulnerability details, enabling:
- Single-click navigation to fix PR/branch
- Automated closure when linked ticket resolves
- Tracking fix progress through issue workflow

### Slash Command Integration

In supported platforms (GitHub, GitLab):

```
/devguard mitigate CVE-2024-0001 fix --due-date 2024-02-15
/devguard accept CVE-2024-0002 --justification "Risk accepted by CISO"
/devguard transfer CVE-2024-0003 --upstream "openssl"
```

## Upstream State Synchronization

For dependencies with supplier VEX statements:

### How It Works

1. **Supplier publishes VEX**: Upstream library maintainer releases VEX statement (CSAF format)
2. **DevGuard ingests VEX**: Automatic integration of upstream statements
3. **State comparison**: 
   - **Actual State**: What DevGuard locally detected
   - **Upstream State**: What supplier claims in VEX
4. **Sync options**: Accept upstream state or maintain local assessment

### Paranoid Mode

For heightened security posture:

- Require manual acceptance of upstream VEX statements
- Don't automatically trust supplier assessments
- Maintain independence from upstream risk assessments
- Useful for zero-trust supply chain environments

## Monitoring Fix Velocity

Track your team's remediation effectiveness:

### Key Metrics

- **Mean Time to Fix (MTTF)**: Average days from detection to resolution by severity
- **Fix Rate**: Vulnerabilities resolved per week/month
- **Backlog Trend**: Open vs. fixed over time
- **Priority Response**: Time to address critical/high severity items

### Best Practices

1. **Set SLAs**: Define target fix times by severity
   - Critical: 7 days
   - High: 14 days
   - Medium: 30 days
   - Low: 90 days

2. **Regular Reviews**: Weekly/monthly assessment of fix progress
3. **Bottleneck Analysis**: Identify categories taking longest to remediate
4. **Trend Improvement**: Track month-over-month fix velocity

## Advanced: Mechanical Justifications and VEX

DevGuard supports the VEX (Vulnerability Exploitability eXchange) standard for non-fix mitigations:

### VEX Component Justifications

CSAF (Common Security Advisory Framework) defines these justification components:

- **component_not_present**: Complete removal of vulnerable dependency
- **vulnerable_code_not_present**: Component included but vulnerable code excluded
- **vulnerable_code_not_in_execute_path**: Code present but unreachable code paths
- **vulnerable_code_cannot_be_controlled_by_adversary**: Code present but requires authenticated/privileged access
- **inline_mitigations_already_exist**: Compensating controls prevent exploitation

### Creating VEX-Compliant Statements

When marking vulnerabilities as non-fixed:

1. Select "Mechanical Justification" option
2. Choose appropriate VEX component justification
3. Add supporting technical evidence in manual justification field
4. This creates exportable CSAF/VEX-compliant statements

### Exporting for Compliance

Your vulnerability statements can be exported in:
- **CSAF Format**: For upstream suppliers and customers
- **VEX JSON**: Standard vulnerability exploitability format
- **SBOMv2 with VEX**: Combined artifact tracking


## See Also

- [Customize Risk Scores](/how-to-guides/vulnerability-management/customize-risk-scores) - Adjust risk based on context
- [Scan Dependencies](/how-to-guides/scanning/scan-dependencies) - Detect vulnerabilities to fix
- [Scan Source Code](/how-to-guides/scanning/scan-source-code) - Find and remediate code issues
